# Инструкции по Git
* git log - журнал изменений
* git log -p filename.txt - вывод всех изменений в файле
* git config --global alias.co checkout - создание сокращенной команды(вместо co подставляется сокращение, вместо commit - полное название команды)
## Команды VIM
* ESC - переход в командный режим
* i - режим редактирования текста
* ZQ(поочередное нажатие, SHIFT зажат) - выход без сохранения
* ZZ(поочередное нажатие, SHIFT зажат) - сохранить и выйти
### В командном режиме:

* :q! - выйти без сохранения
* :wq - сохранить и выйти
* :w filename.txt - сохранить как filename.txt

## Консольные команды

### Репозитории

* git init - создать новый проект в текущей директории
* git init folder-name - создать новый проект в указанной директории
* git clone http... - клонировать удаленный репозиторий в текущую директорию
* git clone http... folder name - клонировать удаленный репозиторий в указанную директорию

### Просмотр изменений

* git status - показать состояние репозитория
* git diff - сравнить рабочую директорию и индекс
* git diff --color-words - сравнить рабочую директорию и индекс, показать отличия в словах
* git diff index.html - сравнить файл из рабочей директории и индекс
* git diff HEAD - сравнить рабочую директорию и коммит, на который указывает HEAD
* git diff --staged - сравнить индекс и коммит с HEAD
* git diff master feature - посмотреть что сделано в ветке feature по сравнению с веткой master
* git diff --name only master feature - посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов
* git diff master...feature - посмотреть что сделано в ветке feature с момента расхождения(коммита) с веткой master

### Добавление изменений в индекс

* git add . - добавить в индекс все новые,изменённые, удалённые файлы из текущей директории и её поддиректорий
* git add text.txt - добавить в индекс указанный файл
* git add -i - запустить интерактивную оболочку для добавления в индекс только выбранных файлов
* git add -p - показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании

### Удаление изменений из индекса

* git reset - убрать из индекса все добавленные в него изменения
* git reset readme.txt - убрать из индекса изменения указанного файла

### Отмена изменений

* git checkout text.txt - **ОПАСНО** отменить изменения в файле, вернуть состояние файла, имеющееся в индексе
* git reset --hard - **ОПАСНО** отменить изменения, вернуть то, что в коммите, на который указывает HEAD
* git clean -df - удалить неотслеживаемые файлы

### Коммиты

* git commit -m "Name_of_commit" - зафиксировать в коммите проиндексированные изменения, добавить сообщение
* git commit -a -m "Name_of_commit" - проиндексировать *отслеживаемые* файлы и закоммитить, добавить сообщение

### Отмена коммитов и перемещение по истории

Все коммиты которые были отправлены в удалённый репозиторий, должны отменяться новыми коммитами, дабы избежать проблем с историей разработки у других участников проекта.

* git revert HEAD --no-edit - создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения 
* git revert b4746 --no-edit - то же, но отменяются изменения, внесенные коммитом с указанным хешем

Все команды, написанные ниже *ТОЛЬКО* если коммиты не были отправлены в удалённый репозиторий

**Опасно, можно потерять незакоммиченные изменения**

* git commit --amend -m "name" - перекоммитить изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текующую ветку на один коммит назад, сохранив рабочую директорию и индекс "как есть", создать новый коммит с данными из отменяемого коммита, но новым сообщением)
* git reset --hard @~ - передвинуть HEAD на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита
* git reset --hard ***** - то же самое, что выше,но с коммитом, чей хеш указан
* git reset --soft @~ - передвинуть HEAD на предыдущий коммит, но в рабочей директории и индексе оставить все изменения
* git reset --soft @~2 - то же самое, что выше, но передвинуть на 2 коммита назад
* git reset @~ - передвинуть HEAD на предыдущий коммит, рабочую директорию оставить, индекс сделать таким, каким он был в момент предыдущего коммита(удобнее чем --soft, если индекс нужно задать заново)

*Почти как git reset --hard, но безопаснее: не потеряются изменения в рабочей директории*

* git reset --keep @~ - передвинуть HEAD на предыдущий коммит, сбросить индекс, но в рабочей директории оставить все изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдет)

### Временно переключиться на другой коммит

* git checkout **** - переключиться на коммит с указанным хешем
* git checkout master - переключиться на коммит, на который указывает master

### Переключиться на другой коммит и работать с него

* git checkout -b new-branch ***** - создать новую ветку "new-branch", начинающуюся с коммита с хешем ****

### Восстановление изменений

* git checkout **** index.html - восстановить в рабочей директории указанный файл на момент указанного коммита

### Копирование коммита(перенос)

* git cherry-pick **** - скопировать на активную ветку изменения из указанного коммита, закоммитить эти данные
* git cherry-pick master~2..master - скопировать на активную ветку изменения из master(2 последних)
* git cherry-pick -n **** - скопировать на активную ветку изменения из указанного коммита, *но НЕ коммитить*
* git cherry-pick master..feature - скопировать на активную ветку изменения из всех коммитов ветки feature с момента ее расхождения с master
* git cherry-pick --abort - прервать конфликтный перенос коммитов
* git cherry_pick --continue - продолжить конфликтный перенос коммитов

### Удаление файла

* git rm text.txt - удалить отслеживаемый неизменённый файл и проиндексировать изменение
* git rm -f text.txt - удалить отслеживаемый измененный файл, проиндексировать изменение
* git rm -r log - удалить всё содержимое отслеживаемой директории log, проиндексировать это изменение
* git rm ind* - удалить все отслеживаемые файлы с именем, начинающмся на ind в текущей директории, проиндексировать изменение
* git rm --cashed readme.txt - удалить из отслеживаемых индексированный файл(Файл останется на месте)

### Перемещение/переименование файлов

Для git не существует переименования. Переименование воспринимается как удаление старого файла и создание нового. Факт переименования может быть определён только после индексации изменения.

* git mv text.txt text-new.txt - переименовать файл text.txt и проиндексировать изменение
* git mv readme.txt folder - переместить файл readme.txt в папку folder, проиндексировать это изменение

### История коммитов

* git log master - показать коммиты в указанной ветке
* git log -2 - показать последние 2 коммита в активной ветке
* git log -2 --stat - показать последние 2 коммита и статистику внесенных ими изменений
* git log -p -22 - показать последние 22 коммита и внесенную ими разницу на уровне строк
* git log --graph -10 - показать последние 10 коммитов с ASCII-представлением ветвления
* git log --since=2.weeks - показать коммиты за последние 2 неделли
* git log --after 'YYYY-MM-DD' - показать коммиты сделанные после указанной даты
* git log index.html - показать историю изменения файла index.html(только коммиты)
* git log -5 index.html - показать историю изменения файла, последние 5 коммитов
* git log -p index.html - показать историю изменения файла (коммиты и изменения)
* git log -G'myFunction' -p - показать все коммиты, в которых менялись строки с myFunction
* git log -L '/<"head">/','\/<"head">/':index.html - показать изменения от указанного до указанного регулярных выражений в указанном файле
* git log --grep fix - показать коммиты в которых есть буквосочетание "fix"(регистрозависимо, только в текущей ветке)
* git log --grep fix -i - показать коммиты с буквосочетанием(регистроНЕзависимо, только в текущей ветке)
* git log --grep 'fix(ing|me)' -P - показать коммиты в которых есть совпадения для регулярного выражения
* git log --pretty=format:"%h - %an, %ar : %s" -4 - показать последние 4 коммита с форматированием выводимых данных
* git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short - чей-то формат вывода, висящий на алиасе оболочки
* git log master..branch_99 - показать коммиты из ветки brunch_99, которые не влиты в master
* git log branch_99..master - показать коммиты из ветки master, которые не влиты в brunch_99
* git log master...branch_99 --boundary --graph - показать коммиты из указанных веток, начиная с их расхождения
* git show **** - показать изменения из коммита с указанным хешем
* git show HEAD~ - показать данные о предыдущем коммите в активной ветке
* git show @~ - то же самое
* git show HEAD~3 - показать данные о коммите, который был 3 коммита назда
* git show my_brunch~2 - показать данные о коммите, который был 2 коммита назда в указанной ветке
* git show @~:index.html - показать контент указанного файла на момент предыдущего(от HEAD) коммита
* git show :/"слово" - показать самый новый коммит, в описании которого есть указанное слово

### Кто написал строку

* git blame README.md --date=short -L 5,8 - показать строки 5-8 указанного файла и коммиты, в которых строки были добавлены

### История изменения указателей (веток, HEAD)

* git reflog -20 - показать последние 20 изменений положения указателя HEAD
* git reflog --format='%C(auto)%h %<|(20)%gd %C(blue)%cr%C(reset) %gs (%s)' -20 - то же, но с указанием давности действий

### Ветки

* git branch - показать список веток
* git branch -v - показать список веток и последний коммит каждой
* git branch new_branch - создать новую ветку с указанным именем на текущем коммите
* git branch new_branch **** - создать новую ветку с указанным именем на указанном коммите
* git branch -f master **** - переместить ветку master на указанный коммит
* git branch -f master master~2 - переместить ветку master на 2 коммита назад
* git checkout new_branch - перейти в указанную ветку
* git checkout -b new_branch - создать новую ветку с указанным именем и перейти в неё
* git checkout -B master **** - переместить указанную ветку на указанный коммит и перейти в неё
* git merge hotfix - влить в ветку в которой находимся, ветку hotfix
* git merge hotfix -m 'горячая правка' - влить в ветку, в которой находимся ветку hotfix с комментарием для коммита слияния
* git merge hotfix --log - влить в ветку, в которой находимся ветку hotfix, показать редактор описания коммита добавить в него сообщение вливаемых коммитов
* git merge hotfix --no-ff - влить в ветку, в которой находимся ветку hotfix, запретить простой сдвиг указателя, изменения из hotfix "останутся" в ней, а в активной ветке появится только коммит слияния
* git branch -d hotfix - удалить ветку hotfix(если она уже влита)
* git branch --merged - показать ветки, уже слитые с активной
* git branch --no-merged - показать ветки, не слиыте с активной
* git brach -a - показать все имеющиеся ветки(в т.ч. на удалённых репозиториях)
* git branch -m old_branch_name new_branch_name - переименовать локально ветку из old в new
* git branch -m new_branch_name - переименовать текущую локальную ветку
* git push origin :old_branch_name new_branch_name - применить переименование на удалённом сервере
* git branch --unset-upstream - завершить процесс переименования

### Теги

* git tag v1.0.0.0 - создать тег с указанным именем на коммиите, на который указывает HEAD
* git tag -a -m 'В продакшн!' v.1.0.1 master - создать тег с описанием на том коммите, на который смотрит ветка master
* git tag -d v.1.0.0.0 - удалить тег с указанным именем(ами)
* git tag -n - показать все теги, и по 1 строке сообщения коммитов, на которые они указывают
* git tag -n -1 'v.1*' - показать все теги, которые начинаются с 'v.1*'

### Временное сохранения без коммита

* git stash - временно сохранить незакомиченные изменения и убрать их из рабочей директории
* git stash pop - вернуть сохраненные командой git stash изменения в рабочую директорию

### Удалённые репозитории

Есть 2 способа привязки удаленных репозиториев: по SSH и HTTPS. Ниже про HTTPS.

* git remote -v - показать список удаленных репозиториев, связанных с локальным
* git branch -r - показать удаленные ветки
* git branch -a - показать все ветки(и локальные, и удаленные)
* git remote remove origin - убрать привязку удаленного репозитория с сокр. именем origin
* git remote add origin https:... - добавить удаленный репозиторий (с сокр. именем origin) по указанному URl
* git remote rm origin - удалить привязку удаленного репозитория
* git remote show origin - получить данные об удаленном репозитории с сокр origin
* git fletch origin - скачать все ветки с удаленного репозитория(origin), но не сливать со своими ветками
* git fletch origin master - то же самое, но скачивается указанная ветка
* git checkout --treck origin/github_brunch - создать локальную ветку github_branch(данные взять с удаленного репозитория с сокр. именем origin, ветка github_branch), и переключиться на неё
* git push origin master - отправить в удаленный репозиторий(origin) свою ветку master
* git pull origin - влить изменения с удаленного репозитория(все ветки)
* git pull origin master - влить изменения с удаленного репозитория(только указанная ветка)

### Конфликт слияния

### Перенос ветки

Можно "переместить" ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в "переносимой" ветке появились какие-либо изменения, внесённые в основной ветке(уже после ответвления переносимой). Также это можно использовать **вместо** слияния веток, для более красивого и понятного оформления истории создания файлов. 
### **НЕЛЬЗЯ "ПЕРЕНОСИТЬ" ВЕТКУ, ЕСЛИ ОНА УЖЕ ОТПРАВЛЕНА НА УДАЛЕННЫЙ РЕПОЗИТОРИЙ** 

 * git rebase master - перенести все коммиты(создать их копии) активной ветки так, будто активная ветка ответвлилась от master на нынешней вершине master(часто вызывает конфликты)
 * git rebase --onto master feature - перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка ответвлилась от feature
 * git rebase --abort - прервать конфликтый rebase, вернуть рабочую директорию и индекс к состоянию до его начала
 * git rebase --continue - продолжить конфликтый rebase(сработает только после разрешения конфликта и индексации такого разрешения)

Отмена rebase:

 * git reflog feature -2 - смотрим лог перемещений ветки, которой делали rebase(feature), видим последний коммит **ПЕРЕД** rebase, на него и нужно перенести указатель ветки
 * git reset --hard feature@{1} - переместить указатель ветки feature на один коммит назад, обновить рабочую директорию и индекс

### Разное

* git archive -o ./project.zip HEAD - создать архив с файловой структурой проекта по указанному пути (состояние репозитория, соответствующее указателю HEAD)
