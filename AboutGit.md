# Настройка Git
Вы установили себе Git и можете им пользоваться. Давайте теперь его настроим, чтобы когда вы создавали commit, указывался автор, кто его создал.

Открываем терминал (Linux и MacOS) или консоль (Windows) и вводим следующие команды.

*#Установим имя для вашего пользователя*

*#Вместо <ваше_имя> можно ввести, например, Grisha_Popov*

*#Кавычки оставляем*

git config --global user.name "<ваше_имя>"

*#Теперь установим email. Принцип тот же.*

git config --global user.email "<адрес_почты@email.com>"

# Создание репозитория

Теперь вы готовы к работе с Git локально на компьютере.

Создадим наш первый репозиторий. Для этого пройдите в папку вашего проекта.

#Для Linux и MacOS путь может выглядеть так /Users/UserName/Desktop/MyProject
#Для Windows например С://MyProject
cd <путь_к_вашему_проекту>

#Инициализация/создание репозитория
git init

Теперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий в нем нет вашего кода. Для этого необходимо создать commit.

#Добавим все файлы проекта в нам будующий commit
git add .
#Или так
git add --all

#Если хотим добавить конкретный файл то можно так
git add <имя_файла> 

#Теперь создаем commit. Обязательно указываем комментарий.
#И не забываем про кавычки
git commit -m "<комментарий>"

# Процесс работы с Git

Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

* Создан новый функционал

* Добавлен новый блок на верстке

* Исправлены ошибки по коду

* Вы завершили рабочий день и хотите сохранить код

Это поможет держать вашу ветки в чистоте и порядке. Тем самым, вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

# Синтаксис языка Markdown

- # Заголовок – выделение заголовков. Количество символов “#” задаёт уровень заголовка
(поддерживается 6 уровней).
- = или - – подчёркиванием этими символами (не менее 3 подряд) выделяют заголовки
первого (“=”) и второго (“-”) уровней.
- ** Полужирное начертание** или __ Полужирное начертание__
- *Курсивное начертание* или _Курсивное начертание_
- ***Полужирное курсивное начертание***
- ~~Зачёркнутый текст~~
- * Строка – ненумерованные списки, символ “*” в начале строки
- 1, 2, 3 … – нумерованные списки

# Git конфликты 

How do I resolve merge conflicts in a Git repository?
!(https://stackoverflow.com/questions/161813/how-do-i-resolve-merge-conflicts-in-a-git-repository)

git mergetool 

# Ветвление 

- git init – инициализация локального репозитория
- git status – получить информацию от git о его текущем состоянии
- git add – добавить файл или файлы к следующему коммиту
- git commit -m “message” – создание коммита.
- git log – вывод на экран истории всех коммитов с их хеш-кодами
- git branch – посмотреть список веток в репозитории
- git branch <название ветки> – создать новую ветку
- git checkout <название ветки> – переход к другой ветке
- git branch -d <название ветки> – удалить ветку

# Git Conflicts

t opens a GUI that steps you through each conflict, and you get to choose how to merge. Sometimes it requires a bit of hand editing afterwards, but usually it's enough by itself. It is much better than doing the whole thing by hand certainly.
Run the following commands in your terminal

git config merge.tool vimdiff
git config merge.conflictstyle diff3
git config mergetool.prompt false
This will set vimdiff as the default merge tool.

Run the following command in your terminal

git mergetool
You will see a vimdiff display in the following format:

  ╔═══════╦══════╦════════╗
  ║       ║      ║        ║
  ║ LOCAL ║ BASE ║ REMOTE ║
  ║       ║      ║        ║
  ╠═══════╩══════╩════════╣
  ║                       ║
  ║        MERGED         ║
  ║                       ║
  ╚═══════════════════════╝
These 4 views are

LOCAL: this is the file from the current branch
BASE: the common ancestor, how this file looked before both changes
REMOTE: the file you are merging into your branch
MERGED: the merge result; this is what gets saved in the merge commit and used in the future
You can navigate among these views using ctrl+w. You can directly reach the MERGED view using ctrl+w followed by j.

More information about vimdiff navigation is here and here.

You can edit the MERGED view like this:

If you want to get changes from REMOTE

:diffg RE
If you want to get changes from BASE

:diffg BA
If you want to get changes from LOCAL

:diffg LO
Save, Exit, Commit, and Clean up

:wqa save and exit from vi

git commit -m "message"

git clean Remove extra files (e.g. *.orig) created by the diff tool.

# Работа с удалёнными репозиториями

Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

## Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:

`$ git clone https://github.com/schacon/ticgit`

`Cloning into 'ticgit'...`

`remote: Reusing existing pack: 1857, done.`

`remote: Total 1857 (delta 0), reused 0 (delta 0)`

`Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.`

`Resolving deltas: 100% (772/772), done.`

`Checking connectivity... done.`

`$ cd ticgit`

`$ git remote`

`origin`

## Добавление удалённых репозиториев

В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду `git remote add <shortname> <url>`

## Получение изменений из удалённого репозитория — Fetch и Pull

Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:

`$ git fetch [remote-name]`

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, `git fetch origin` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда `git fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки (см. следующий раздел и главу Ветвление в Git чтобы получить больше информации), то вы можете использовать команду `git pull` чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение `git pull`, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.